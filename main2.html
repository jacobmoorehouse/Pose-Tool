<!DOCTYPE html>
<head>
<title>Codine's Posing Tool!</title>
<link rel="stylesheet" type="text/css" href="style.css">
<script type="text/javascript" src="three.js"></script>
</head>

<body>
<h1> Welcome to our posing tool! </h1>

<p class = "Intro" style = "display:none"> We will be building a posing tool that recreates the human body and allow artists to have a 
	semi-realistic reference. Each part of the body will be able to rotate a full 360 degrees except 
	exceptions that we feel will be needed. 
	In order to do this we will program every limb as a straight, unbendable rod and each joint as a sphere.
	Then we will replace each rod with a 3D model of what object should be there.
	The user will be able to fully rotate the entire body by dragging the screen and perhaps even zooming in.
	Additionally, we will allow the user to save the current pose as a jpeg for future reference, 
	and even change certain features of the human body, and changing its gender. <p>
<p class = "Names"> Codine is made of Junze He and Jacob Moorehouse. </p>

<!--<canvas id="cvas" height= "20" width = "20" style = "border: 2px inset #0056af">Your Web Browser Does Not Support HTML5.</canvas>
-->
<script>
	var container, stats;

			var camera, scene, renderer;

			var cube, plane;

			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function init() {
				
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 123;
				camera.position.z = 420;

				scene = new THREE.Scene();

				// Cube

				var geometry = new THREE.CubeGeometry( 75, 75, 100 );

				for ( var i = 0; i < geometry.faces.length; i += 2 ) {

					var hex = Math.random() * 0xffffff;
					geometry.faces[ i ].color.setHex( hex );
					geometry.faces[ i + 1 ].color.setHex( hex );

				}

				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
				var secondMaterial = new THREE.MeshLambertMaterial( {color: "0x56ffee"}); 
				
				cube = new THREE.Mesh( geometry,new THREE.MeshPhongMaterial({   specular: '#a9fcff',
				color: '#00abb1', emissive: '#006063',   shininess: 250}));
				cube.position.y = 150;
				scene.add( cube );

				// Plane

				var geometry = new THREE.PlaneGeometry( 200, 200 );
				geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

				var material = new THREE.MeshBasicMaterial( { color: 0xe0e0e0, overdraw: 0.5 } );

				plane = new THREE.Mesh( geometry, material );
				plane.position.y = -75; 
				scene.add( plane );
				
				head = new THREE.Mesh(new THREE.SphereGeometry(60,15,15),new THREE.MeshPhongMaterial({   specular: '#a9fcff',
				color: '#00abb1', emissive: '#006063',   shininess: 250})); 
				head.position.y = 280;
				scene.add(head);
				
				skirt = new THREE.Mesh(new THREE.CylinderGeometry(0, 75, 120, 5, 7, false), new THREE.MeshPhongMaterial({   specular: '#a9fcff',
				color: '#00abb1', emissive: '#006063',   shininess: 250}));
				skirt.position.y += 25;
				scene.add(skirt);
				
				lighting = new THREE.PointLight(0xFFFFFF); 
				lighting.position.x = 100; 
				lighting.position.y = 100; 
				lighting.position.z = 100; 
				scene.add(lighting); 
			
				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );		
				

				window.onmousedown=function(){onDocumentMouseDown(event)	}; 
				//document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				
			

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseDown( event ) {
				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

			}

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentMouseOut( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {
				
				skirt.rotation.y = head.rotation.y = plane.rotation.y = cube.rotation.y += ( targetRotation - cube.rotation.y ) * 0.05;
				
				renderer.render( scene, camera );

			}

</script>


<p style = "font-size:1.8em"> Features we hope to implement </p>
<ul>
<li>Saving image to file for future reference</li>
<li>Selecting Certain Parts to rotate instead of the whole body</li> 
<li>Realistic Body Parts (probably through 3D sculpting software)</li> 
</ul>

</body>



</html>